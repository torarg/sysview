#!/bin/sh

usage="usage: sysview [-hV] HTML_ROOT"
cache_dir="$HOME/.cache/sysview"
config_dir="/usr/local/share/sysview"
css_file="${config_dir}/style.css"

version="0.0.1"

err_exit() {
    echo "error: $@" 1>&2
    exit 1
}

html_head() {
    echo "$(cat <<EOF
<html>
    <head>
        <title>$1</title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
    <header>
        <div><a class="header_link" href=index.html>sysview</a></div>
        <div>:</div>
        <div>$1</div>
    </header>
    <main>
    <section class="tiles-container">
EOF
)"
}

html_foot() {
    echo "$(cat <<EOF
    </section>
    </main>
    <footer>
    <div>
        <pre id="legend" class="item_ok">OK</pre>
        <pre id="legend" class="item_warning">Warning</pre>
        <pre id="legend" class="item_critical">Critical</pre>
        <pre id="legend" class="item_unknown">Unknown</pre>
        <pre id="legend" class="item_outdated">Outdated</pre>
    </div>
    </body>
</html>
EOF
)"
}


parse_report_items() {
    item_count=0
    item_pointer=0
    while read line; do
        if echo "$line" |egrep -q '^OK:|^CRITICAL:|^WARNING:|^UNKNOWN:'; then
            item_status="$(echo $line | cut -f 1 -d ':' |  tr '[:upper:]' '[:lower:]')"
            items="${items}$(echo "Last seen: $date")\n"
        fi
        if [ "$line" == "---" ] && [ "$item_count" -eq "0" ]; then
            item_count=1
            item_pointer=1
            items="${items}<pre class=\"CSS_CLASS\">\n"
        elif [ "$line" == "---" ] && [ "$item_count" -gt "0" ]; then
            items="${items}</pre>"
            item_count="$((item_count + 1 ))"
            items="$(echo "$items" | sed "s/CSS_CLASS/item_$item_status/g")"
            item_status=""
        elif [ "$item_count" -gt "0" ] && [ "$item_pointer" -ne "$item_count" ]; then
            items="${items}<pre class=\"CSS_CLASS\">\n${line}\n"
            item_pointer="$((item_pointer + 1 ))"
        elif [ "$item_count" -gt "0" ]; then
            items="${items}${line}\n"
        fi
    done
    if [ -n "$items" ]; then
        items="$(echo "$items" | sed '$ d')"
        items="$items\n</pre>"
    fi
    items="$(echo "$items" | sed "s/CSS_CLASS/item_$item_status/g")"
    echo "$items"
}


parse_report() {
    report_started=0
    report=""

    while read line; do
        if [[ "$line" == "Hostname: "* ]] ; then
            report_started=1
            hostname=$(echo "$line" | awk '{ print $2 }')
            report="${report}${line}\n"
        elif [[ "$line" == "Date: "* ]] && [ "$report_started" -eq "1" ]; then
            date=$(echo "$line" | cut -f 2- -d " ")
            report="${report}${line}\n"
        elif [[ "$line" == "Type: "* ]] && [ "$report_started" -eq "1" ]; then
            type=$(echo "$line" | cut -f 2- -d " ")
            report="${report}${line}\n"
        elif [ "$report_started" -eq "1" ]; then
            report="${report}${line}\n"
        fi
    done

    if [ -z "$hostname" ] || [ -z "$date" ] || [ -z "$report" ]; then
        echo "failed parsing report"
        exit 0
    fi

    [ -z "$type" ] && type="sysreport" # fallback for now, since this is a new field
    #echo "$report"
}

get_worst_status() {
    text="$report"
    if stat -q ${cache_dir}/${hostname}.html.detail.part.* > /dev/null; then
        #find ${cache_dir}/${hostname}.html.detail.part.* -mtime -1 -exec sed -i 's/pre class="item_outdated.*$/pre class="item_ok">/g' {} \;
        find ${cache_dir}/${hostname}.html.detail.part.* -mtime +1 -exec sed -i 's/pre class="item_.*$/pre class="item_outdated">/g' {} \;
        for file in  ${cache_dir}/${hostname}.html.detail.part.*; do
            if [[ "$file" == *".part.${type}"* ]]; then
                continue
            fi
            text="${text}\n$(cat ${file})"
        done
    fi

    if echo "$text" | egrep -q '<pre class="item_outdated">'; then
        worst_status="outdated"
    elif echo "$text" | grep -q "CRITICAL: "; then
        worst_status="crit"
    elif echo "$text" | grep -q "WARNING: "; then
        worst_status="warn"
    elif echo "$text" | grep -q "OK: "; then
        worst_status="ok"
    else
        worst_status="unknown"
    fi
}

update_cache() {
    worst_status="unknown"
    parse_report
    report_items="$(echo "$report" | parse_report_items)"
    get_worst_status
    overview_part="${cache_dir}/${hostname}.html.overview.part"
    detail_view_part="${cache_dir}/${hostname}.html.detail.part.${type}"
    [ -f "$overview_part" ] && rm $overview_part
    [ -f "$detail_view_part" ] && rm $detail_view_part

    cat > ${overview_part} <<EOF
<a href="$hostname.html">
    <div class="tile_$worst_status">
        <h4>$hostname</h5>
        <p>$date</p>
    </div>
</a>
EOF

    echo "$report_items" >> $detail_view_part

}

render_cache() {
    tmp_index_file="${cache_dir}/index.html"
    tmp_detail_file="${cache_dir}/${hostname}.html"

    # render overview
    html_head "overview" > $tmp_index_file
    for file in ${cache_dir}/*.overview.part; do
        if grep -q tile_crit $file; then
            cat $file >> $tmp_index_file
        fi
    done
    for file in ${cache_dir}/*.overview.part; do
        if egrep -q 'tile_outdated|tile_warn' $file; then
            cat $file >> $tmp_index_file
        fi
    done
    for file in ${cache_dir}/*.overview.part; do
        if grep -q tile_ok $file; then
            cat $file >> $tmp_index_file
        fi
    done
    html_foot >> $tmp_index_file
    cp $tmp_index_file $html_root/index.html


    # render detail views
    html_head "$hostname" > $tmp_detail_file
    for file in ${cache_dir}/${hostname}.html.detail.part.*; do
        cat $file >> $tmp_detail_file
    done
    html_foot >> $tmp_detail_file
    cp $tmp_detail_file $html_root/$hostname.html
}

while getopts :hV flag; do
    case "${flag}" in
        h) echo "$usage" && exit 0 ;;
        V) echo "$version" && exit 0 ;;
        ?) err_exit "invalid args" ;;
    esac
done
shift $(($OPTIND - 1))

html_root="$1"

[ -z "$html_root" ] && err_exit "no html root"
[ ! -d "$cache_dir" ] && mkdir -p "$cache_dir" 

cp $css_file $html_root/
update_cache
render_cache
